# [level 4] 사칙연산 - 1843 

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/1843) 

### 성능 요약

메모리: 11.3 MB, 시간: 377.91 ms

### 구분

코딩테스트 연습 > 동적계획법（Dynamic Programming）

### 채점결과

정확성: 55.6<br/>효율성: 44.4<br/>합계: 100.0 / 100.0

### 제출 일자

2025년 01월 23일 12:27:51

### 문제 설명

<p>사칙연산에서 더하기(+)는 결합법칙이 성립하지만, 빼기(-)는 결합법칙이 성립하지 않습니다.<br>
예를 들어 식 1 - 5 - 3은 연산 순서에 따라 다음과 같이 다른 결과를 가집니다.</p>

<ul>
<li>((1 - 5) - 3) = -7</li>
<li>(1 - (5 - 3)) = -1</li>
</ul>

<p>위 예시와 같이 뺄셈은 연산 순서에 따라 그 결과가 바뀔 수 있습니다.<br>
또 다른 예로 식 1 - 3 + 5 - 8은 연산 순서에 따라 다음과 같이 5가지 결과가 나옵니다.</p>

<ul>
<li>(((1 - 3) + 5) - 8) = -5</li>
<li>((1 - (3 + 5)) - 8) = -15</li>
<li>(1 - ((3 + 5) - 8)) = 1</li>
<li>(1 - (3 + (5 - 8))) = 1</li>
<li>((1 - 3) + (5 - 8)) = -5</li>
</ul>

<p>위와 같이 서로 다른 연산 순서의 계산 결과는 <code>[-15, -5, -5, 1, 1]</code>이 되며, 이중 최댓값은 1입니다.<br>
문자열 형태의 숫자와, 더하기 기호("+"), 뺄셈 기호("-")가 들어있는 배열 arr가 매개변수로 주어질 때, 서로 다른 연산순서의 계산 결과 중 최댓값을 return 하도록 solution 함수를 완성해 주세요.</p>

<h5>제한 사항</h5>

<ul>
<li>arr는 두 연산자 "+", "-" 와 숫자가 들어있는 배열이며, 길이는 3 이상 201 이하 입니다.

<ul>
<li>arr의 길이는 항상 홀수입니다.</li>
<li>arr에 들어있는 숫자의 개수는 2개 이상 101개 이하이며, 연산자의 개수는 (숫자의 개수) -1 입니다.</li>
<li>숫자는 1 이상 1,000 이하의 자연수가 문자열 형태로 들어있습니다.. (ex : "456")</li>
</ul></li>
<li>배열의 첫 번째 원소와 마지막 원소는 반드시 숫자이며, 숫자와 연산자가 항상 번갈아가며 들어있습니다.</li>
</ul>

<hr>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>arr</th>
<th>result</th>
</tr>
</thead>
        <tbody><tr>
<td>["1", "-", "3", "+", "5", "-", "8"]</td>
<td>1</td>
</tr>
<tr>
<td>["5", "-", "3", "+", "1", "+", "2", "-", "4"]</td>
<td>3</td>
</tr>
</tbody>
      </table>
<h5>입출력 예시</h5>

<p>입출력 예 #1<br>
위의 예시와 같이 (1-(3+(5-8))) = 1 입니다.</p>

<p>입출력 예 #2<br>
(5-(3+((1+2)-4))) = 3 입니다.</p>


> 출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges


### 풀이방법
1. 1부터 N개만큼 숫자를 묶어서 작은 부분부터 최솟값, 최댓값을 구해간다.
2. 경우에 따른 계산 방법은 아래와 같다.  
- 하나의 숫자만 있는 경우 (연산자x)
  - 각각의 숫자는 그 자체가 최솟값이자 최댓값
- 두 개의 숫자가 있는 경우
  - 두 개의 숫자에 연산자를 적용한 값이 최솟값이자 최댓값
- 세 개이상의 숫자가 있는 경우
  - 구간을 둘로 나눌 수 있는 모든 경우의 수를 구한다.
  - 나눈 왼쪽 구간과 오른쪽 구간에 연산자를 적용시켜 계산한다.
  - 이 때 나온 최소값과 최댓값으로 새로운 최솟값과 최댓값을 찾는다.

### 회고
1. 이전에 풀어봤던 연쇄행렬곱셈 문제가 떠올라서 비슷한 접근방법을 구상할 수 있었다. 
2. '-' 연산자를 고려하면 부분 문제에서 최댓값만 계산해서는 항상 최댓값을 보장할 수 없었다.
3. 이 부분을 놓쳐서 시간이 더 걸렸다.
4. 또한 모든 경우의 수를 구하는데 있어서 누락된 경우의 수가 있어서 추가적으로 시간이 소요됐다.
5. 슷자가 작은 케이스로 입출력을 계산하는 과정을 좋았다. 그러나 표본 수가 너무 적었기에 경우의 수가 누락되는 문제가 발생했다. 
6. 다음에는 몇개의 케이스를 더 고려해서 진행해보면 좋을 것 같다.
